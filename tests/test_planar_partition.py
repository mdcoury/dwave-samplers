# Copyright 2022 D-Wave Systems Inc.
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#   http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS F ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.

import itertools
import random
import unittest

import dimod
import numpy as np
import scipy

from dwave.samplers.planar import *
from test_planar_kasteleyn import _kasteleyn


# TODO: Should this whole test-class be removed?  I can't tell if the tests are indirectly testing something important


def _logsqrtdet(K):
    """Calculate ln(sqrt(|K|)).

    Args:
        K (np.ndarray):
            A Kasteleyn matrix as generated by :func:`.kasteleyn`.

    Returns:
        float: ln(sqrt(|K|))

    Note:
        Only works for |K| >= 0.

    """
    # LU decomposition
    # noinspection PyTupleAssignmentBalance
    _, U = scipy.linalg.lu(K, permute_l=True)

    return .5 * np.sum(np.log(np.absolute(np.diag(U))))


def _log_partition_bqm(bqm, pos):
    if len(bqm) < 3:
        raise ValueError("bqm must have at least three variables")

    G, off = bqm_to_multigraph(bqm)

    # apply the rotation system
    r = rotation_from_coordinates(G, pos)
    nx.set_node_attributes(G, name='rotation', values=r)

    # triangulation
    plane_triangulate(G)

    # get the odd edge orientation
    orientation = odd_in_degree_orientation(G)
    nx.set_edge_attributes(G, name='oriented', values=orientation)

    # to establish clockwise odd orientation of the expanded dual, all vertices, except possibly 1
    # should have an odd in-degree
    assert sum(bool(sum(data['oriented'] == v for _, _, data in G.edges(v, data=True)) % 2) for v in G) >= len(G) - 1

    # create an edge indexing scheme
    indices = {edge: idx for idx, edge in enumerate(G.edges(keys=True))}
    nx.set_edge_attributes(G, name='index', values=indices)

    # now build the Kasteleyn
    K = _kasteleyn(G)

    # the ln(2) comes from there being twice as many states (in our version of a bqm) as perfect matchings
    # because the BQM has only 0 linear biases. Therefore for each sample than minimized the BQM,
    # its inverse also minimizes.
    return _logsqrtdet(K) - (sum(G.edges[e].get('weight', 0.0) for e in G.edges(keys=True)) + off) + np.log(2)


class TestLogPartitionBQM(unittest.TestCase):
    def test_three_path_bqm(self):
        bqm = dimod.BinaryQuadraticModel.empty(dimod.SPIN)

        bqm.add_interaction(0, 1, .69)
        bqm.add_interaction(1, 2, +1.0)
        bqm.add_interaction(2, 0, .5)

        pos = {0: (0, 0), 1: (1, 0), 2: (0, 1)}

        logZ = _log_partition_bqm(bqm, pos)

        en = list(-bqm.energy(dict(zip(range(len(bqm)), config)))
                  for config in itertools.product((-1, 1), repeat=len(bqm)))

        self.assertAlmostEqual(np.log(np.sum(np.exp(en))), logZ)

    def test_four_path_bqm(self):
        bqm = dimod.BinaryQuadraticModel.empty(dimod.SPIN)

        bqm.add_interaction(0, 1, +1.0)
        bqm.add_interaction(1, 2, +1.0)
        bqm.add_interaction(2, 3, +1.0)
        bqm.add_interaction(0, 3, +1.0)
        bqm.offset += 1.8

        pos = {0: (+1, +1),
               1: (-1, +1),
               2: (-1, -1),
               3: (+1, -1)}

        logZ = _log_partition_bqm(bqm, pos)

        en = list(-bqm.energy(dict(zip(range(len(bqm)), config)))
                  for config in itertools.product((-1, 1), repeat=len(bqm)))

        self.assertAlmostEqual(np.log(np.sum(np.exp(en))), logZ)

    # def test_FrustTriangleL39(self):
    #     from tests.data import bqm_L39, pos_L39
    #
    #     _ = log_partition_bqm(bqm_L39, pos_L39)

    def test_square_with_chord(self):
        bqm = dimod.BinaryQuadraticModel.from_ising({0: -0.0, 1: -0.0, 2: -0.0, 3: -0.0},
                                                    {(1, 2): 2, (0, 1): 1, (1, 3): 1, (2, 3): 1, (0, 2): 1})
        pos = {0: (0, 0), 1: (0, 1), 2: (1, 0), 3: (1, 1)}

        logZ = _log_partition_bqm(bqm, pos)

        en = []
        for config in itertools.product((-1, 1), repeat=len(bqm)):
            sample = dict(zip(range(len(bqm)), config))
            en.append(bqm.energy(sample))

        self.assertAlmostEqual(np.log(np.sum(np.exp(-1*np.asarray(en)))), logZ)

    def test_square_with_chord_2(self):
        bqm = dimod.BinaryQuadraticModel({0: -0.0, 1: -0.0, 2: -0.0, 3: -0.0},
                                         {(1, 2): 200, (0, 1): 100, (1, 3): 100, (2, 3): 100, (0, 2): 100},
                                         -0.0, dimod.SPIN)

        pos = {0: (0, 0), 1: (0, 1), 2: (1, 0), 3: (1, 1)}

        logZ = _log_partition_bqm(bqm, pos)

        en = []
        for config in itertools.product((-1, 1), repeat=len(bqm)):
            sample = dict(zip(range(len(bqm)), config))
            en.append(bqm.energy(sample))

        self.assertAlmostEqual(np.log(np.sum(np.exp(-1*np.asarray(en)))), logZ)

    def test_functional_square_with_chord_random(self):
        nodes = list(range(4))
        edges = [[1, 2], [0, 1], [1, 3], [2, 3], [0, 2]]
        pos = {0: (0, 0), 1: (0, 1), 2: (1, 0), 3: (1, 1)}
        for __ in range(10):
            bqm = dimod.BinaryQuadraticModel.empty(dimod.SPIN)

            random.shuffle(nodes)
            for v in nodes:
                bqm.add_variable(v, 0)

            random.shuffle(edges)
            for edge in edges:
                random.shuffle(edge)
            for u, v in edges:
                bqm.add_interaction(u, v, random.uniform(-1, 1))

            logZ = _log_partition_bqm(bqm, pos)

            en = list(-bqm.energy(dict(zip(range(len(bqm)), config)))
                      for config in itertools.product((-1, 1), repeat=len(bqm)))

            self.assertAlmostEqual(np.log(np.sum(np.exp(en))), logZ)
